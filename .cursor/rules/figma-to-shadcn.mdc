---
description: Workflow for implementing Figma designs using shadcn/ui components with minimal custom styling
globs: 
alwaysApply: false
---

# Figma to shadcn/ui Implementation Workflow

This rule guides AI to implement Figma designs using only shadcn/ui components with minimal custom styling.

## When This Rule Applies

Trigger this workflow when the user provides a Figma URL and asks to implement the design. Common patterns:
- "Implement this design from Figma: [URL]"
- "Build this Figma screen: [URL]"
- "Convert this Figma to code: [URL]"

## Workflow Steps

### Step 1: Extract Figma URL Parameters

Parse the Figma URL to extract `fileKey` and `nodeId`:
- URL format: `https://figma.com/design/:fileKey/:fileName?node-id=:nodeId`
- Convert `node-id` from `123-456` to `123:456` format for API calls

### Step 2: Get Design Context from Figma

Use the Figma MCP to fetch the design:

```
Tool: get_design_context (server: user-Figma Online)
Parameters:
  - fileKey: extracted from URL
  - nodeId: extracted from URL (use colon format: "123:456")
  - clientLanguages: "typescript"
  - clientFrameworks: "react,nextjs"
```

Also fetch a screenshot for visual reference:

```
Tool: get_screenshot (server: user-Figma Online)
Parameters:
  - fileKey: extracted from URL
  - nodeId: extracted from URL
```

### Step 3: Analyze Figma Component Names (CRITICAL)

**BEFORE assuming component types, check the `data-name` attributes in the Figma output.**

The Figma MCP output includes `data-name` attributes that reveal the actual component type:

```jsx
// Example: This looks like buttons but is actually Tabs
<div data-name="Tabs" data-node-id="9:639">
  <div data-name="Tab" data-node-id="189:42605">Label</div>
  <div data-name="Tab" data-node-id="189:42606">Label</div>
</div>
```

**Pattern Recognition Checklist:**

| Visual Appearance | Check `data-name` for | Likely Component |
|-------------------|----------------------|------------------|
| Grouped buttons with one active | `Tabs`, `Tab`, `TabsList` | `<Tabs>` |
| Toggle between options | `Switch`, `Toggle` | `<Switch>` |
| Segmented control | `SegmentedControl`, `Tabs` | `<Tabs>` with pill style |
| Button group | `ButtonGroup`, `Button Group` | `<div>` with buttons or `<ToggleGroup>` |
| Dropdown trigger | `Select`, `Dropdown`, `Combobox` | `<Select>` or `<DropdownMenu>` |
| List with selection | `RadioGroup`, `Radio` | `<RadioGroup>` |

**Red Flags - Stop and Verify:**
- Multiple similar elements in a row (could be Tabs, not Buttons)
- Elements sharing a container background (suggests grouped component)
- Active/inactive states on similar elements (suggests selection component)
- Elements with `rounded` container wrapping them (pill tabs pattern)

### Step 3b: Check Component Variants & Props (ALL Components)

**AFTER identifying the component type, extract ALL variant props from Figma:**

For EVERY component, check:
1. **`data-name`** - Often contains variant info (e.g., "Button/Secondary/sm", "Input/outline")
2. **Dimensions** - Height/width in Figma properties panel
3. **Visual properties** - Fill color, border, shadow indicate variant
4. **State** - Default, hover, active, disabled states

**For shadcn Component Libraries in Figma:**

When the Figma file uses a shadcn component library (like Obra), extract props from **attributes only**, not from CSS pixel values.

**Extraction Process:**
```
1. Call get_metadata → get height attribute (this determines size)
2. Call get_design_context → get CSS variable NAMES (this determines variant)
3. Map attributes to props - ignore implementation details
```

**What to LOOK AT:**
- `get_metadata` → `height` attribute (36 = default, 32 = sm, 24 = xs)
- CSS variable **names**: `--general/primary`, `--general/secondary`, etc.
- `data-name` for component type

**What to IGNORE:**
- Pixel values in generated code (px, py, gap, rounded values)
- These are internal implementation details of the Figma library
- They don't map to props - the library handles them internally

**MCP Output - What Matters:**

```
FROM get_metadata:
┌─────────────────────────────────────────────────┐
│ height attribute - compare between components   │
│ to identify which is default vs sm vs xs        │
│ (don't hardcode pixel→size mappings)            │
└─────────────────────────────────────────────────┘

FROM get_design_context (CSS variable NAMES only):
┌─────────────────────────────────────────────────┐
│ Look for variant keywords in variable names:    │
│ --general/primary     → default (omit prop)     │
│ --general/secondary   → variant="secondary"     │
│ --general/destructive → variant="destructive"   │
└─────────────────────────────────────────────────┘

IGNORE these (implementation details):
┌─────────────────────────────────────────────────┐
│ All pixel values: px, py, gap, rounded, height  │
│ These are internal to the Figma component       │
│ The library handles sizing - just use props     │
└─────────────────────────────────────────────────┘
```

**Priority Order:**
1. `data-name` with variant/size (e.g., "Button/Secondary/sm") → use directly
2. CSS variable names → extract variant (`--general/secondary` → `variant="secondary"`)
3. Compare heights between components → identify relative sizes (don't hardcode px values)
4. **Omitted = default** - if no variant/size indicator, assume default

**Rules:**
- Look for variant keywords in CSS variable names (primary, secondary, destructive)
- **Only add props that differ from default**
- Don't hardcode pixel→prop mappings - compare relatively

**Common Mistakes:**
- Assuming `size="sm"` when Figma shows default size
- Missing `variant="outline"` when component has border
- Forgetting `disabled` state when Figma shows muted colors
- Not checking if icon-only vs text+icon

**Rule: Don't guess ANY prop - extract it from Figma.**

### Step 4: Fetch Variable Definitions (BEFORE mapping components)

**Always fetch Figma variables before implementation:**

```
Tool: get_variable_defs (server: user-Figma Online)
Parameters:
  - fileKey: extracted from URL
  - nodeId: any node from the design
```

This reveals:
- Radius values (`rounded-lg`, `rounded-2xl`, etc.)
- Spacing tokens (`xs`, `sm`, `md`, etc.)
- Color tokens

**Check if these match your CSS variables in `globals.css`. If not, update CSS variables FIRST using the `figma-tokens-sync` workflow.**

### Step 5: Map to shadcn/ui Components

**Based on `data-name` attributes (not visual appearance), map to shadcn components:**

Search for matching shadcn components:

```
Tool: search_items_in_registries (server: user-shadcn/ui)
Parameters:
  - registries: ["@shadcn"]
  - query: "<component type from data-name>"
```

Or list all available components:

```
Tool: list_items_in_registries (server: user-shadcn/ui)
Parameters:
  - registries: ["@shadcn"]
```

### Step 6: View Component Details

For each required component, get implementation details:

```
Tool: view_items_in_registries (server: user-shadcn/ui)
Parameters:
  - items: ["@shadcn/button", "@shadcn/card", ...]
```

And usage examples:

```
Tool: get_item_examples_from_registries (server: user-shadcn/ui)
Parameters:
  - items: ["@shadcn/button", "@shadcn/card", ...]
```

### Step 7: Install Missing Components

Check which components exist in `apps/web/src/components/ui/` and install any missing ones:

```
Tool: get_add_command_for_items (server: user-shadcn/ui)
Parameters:
  - items: ["@shadcn/button", "@shadcn/card", ...]
```

Run the generated command in the `apps/web` directory:
```bash
cd apps/web && npx shadcn@latest add <components>
```

**IMPORTANT: Fix Import Paths**

After installing new components, fix the `cn` utility import path in the newly created files:

```bash
# shadcn generates this (incorrect for this project):
import { cn } from "@/utils/utils"

# Replace with:
import { cn } from '@/utils/cn'
```

Run this replacement in all newly installed component files before proceeding.

### Step 8: Build the Component

Create the React component following these principles:

#### Component Structure
```tsx
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
// ... other shadcn imports

type MyScreenProps = {
  // typed props
}

export const MyScreen = ({ ...props }: MyScreenProps) => {
  return (
    // Implementation using shadcn components
  )
}
```

#### Styling Guidelines

**DO:**
- Use shadcn component variants (e.g., `variant="outline"`, `size="sm"`)
- Use Tailwind for layout only: `flex`, `grid`, `gap-*`, `p-*`, `m-*`, `w-*`, `h-*`
- Use Tailwind for responsive breakpoints: `sm:`, `md:`, `lg:`
- Use CSS variables from the theme for colors when needed

**DON'T:**
- Add custom colors with Tailwind classes (e.g., `bg-blue-500`)
- Override shadcn component styles with Tailwind
- Create custom CSS files for the component
- Use inline styles
- Hardcode pixel values for colors, shadows, borders

#### Layout Patterns

For common layouts, use these Tailwind patterns:

```tsx
// Vertical stack with gap
<div className="flex flex-col gap-4">

// Horizontal layout
<div className="flex items-center gap-2">

// Grid layout
<div className="grid grid-cols-2 gap-4 md:grid-cols-3">

// Container with padding
<div className="p-4 md:p-6">

// Full width with max constraint
<div className="w-full max-w-md mx-auto">
```

### Step 9: Create Storybook Story

Create a story file alongside the component:

```tsx
import type { Meta, StoryObj } from '@storybook/react'
import { MyScreen } from './MyScreen'

const meta = {
  title: 'Screens/MyScreen',
  component: MyScreen,
  tags: ['autodocs'],
} satisfies Meta<typeof MyScreen>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {},
}
```

## Common shadcn Component Mappings

### CRITICAL: Always Verify Size AND Variant for ALL Components

**Every shadcn component has variants and sizes. Never assume defaults - always verify from Figma:**

1. **Check `data-name`** for variant/size indicators (e.g., "Button/Default", "Input/sm", "Card/outline")
2. **Measure dimensions** - height/width in Figma properties panel
3. **Check visual style** - filled vs outline, primary vs secondary, etc.
4. **Compare with component source** - read the component's `variants` in code to understand options

**Key rule:** Only omit props when Figma explicitly uses the default. If unsure, check the component file.

### Component Properties (shadcn Libraries)

For Figma files using shadcn component libraries, these are the common exposed properties:

| Component | Key Properties |
|-----------|---------------|
| Button | `variant`, `size`, `icon`, `disabled` |
| Input | `size`, `disabled`, `error` |
| Select | `size`, `disabled` |
| Avatar | `size`, `src`, `fallback` |
| Badge | `variant` |
| Tabs | `defaultValue`, individual `TabsTrigger` values |
| Card | `size` (if available) |

**Use the Figma properties panel values directly - don't measure pixels.**

### Component Mappings

| Figma Element | shadcn Component |
|---------------|------------------|
| Text Input | `<Input>` |
| Select/Dropdown | `<Select>` |
| Checkbox | `<Checkbox>` |
| Radio | `<RadioGroup>` |
| Toggle/Switch | `<Switch>` |
| Card/Container | `<Card>` |
| Dialog/Modal | `<Dialog>` |
| Tabs | `<Tabs>` |
| Table | `<Table>` |
| Tooltip | `<Tooltip>` |
| Badge/Tag | `<Badge>` |
| Avatar | `<Avatar>` |
| Separator/Divider | `<Separator>` |
| Skeleton/Loading | `<Skeleton>` |
| Alert/Banner | `<Alert>` |
| Accordion | `<Accordion>` |
| Navigation Menu | `<NavigationMenu>` |
| Breadcrumb | `<Breadcrumb>` |
| Pagination | `<Pagination>` |

## Project-Specific Notes

This project uses:
- **Style**: `base-vega`
- **Icon Library**: `lucide` - import icons from `lucide-react`
- **Components Path**: `apps/web/src/components/ui/`
- **Utility Path**: `apps/web/src/utils/cn.ts` (for `cn()` helper)

## Complex Screen Implementation

For full screens (dashboards, pages with multiple sections):

### Component Decomposition Strategy

1. **Identify logical sections** - Each card, panel, or distinct UI region becomes a subcomponent
2. **Extract reusable patterns** - If a pattern appears 2+ times, extract it
3. **Create a main orchestrator** - The screen component imports and composes subcomponents

Example structure for a dashboard:
```
showcase/
├── AssetValueCard.tsx        # Reusable card
├── PendingTransactionsCard.tsx
├── PortfolioCard.tsx
├── CreateProjectCard.tsx
├── WalletSidebar.tsx         # Navigation
├── WalletDashboard.tsx       # Main screen (orchestrator)
└── WalletDashboard.stories.tsx
```

### Data Prop Patterns

For components displaying lists, define clear interfaces:

```tsx
// Define item types
interface Transaction {
  id: string
  title: string
  date: string
  // ...
}

// Props accept arrays + callbacks
interface Props {
  transactions: Transaction[]
  onViewAll?: () => void
  onItemClick?: (id: string) => void
}
```

### Component Dependencies

Some shadcn components have hidden dependencies:
- `sidebar` requires `use-mobile` hook, `sheet`, `skeleton`, `tooltip`
- Always run type-check after installing to catch missing deps
- Install missing dependencies: `npx shadcn@latest add <dep>`

### Naming Conventions

- `*Card` - Self-contained card components (e.g., `AssetValueCard`)
- `*Sidebar` / `*Nav` - Navigation components
- `*Dashboard` / `*Screen` / `*Page` - Full page orchestrators
- Use `PascalCase` for component names

## Validation Checklist

**Before starting implementation:**
- [ ] Checked `data-name` attributes in Figma output for component types
- [ ] Verified grouped elements aren't Tabs/ToggleGroup mistaken for Buttons
- [ ] Extracted variant from CSS variable names (e.g., `--general/secondary`)
- [ ] Compared similar components to identify size differences (relative, not hardcoded)
- [ ] Fetched `get_variable_defs` to check design token values
- [ ] Compared Figma tokens with `globals.css` - updated if needed

**Before completing:**
- [ ] All UI elements use shadcn components (no custom primitives)
- [ ] Custom Tailwind classes are limited to layout/spacing
- [ ] No hardcoded colors - uses theme variables or component variants
- [ ] No hardcoded radius values - uses `rounded-*` classes that map to CSS variables
- [ ] Component is typed with TypeScript interfaces
- [ ] Storybook story is created
- [ ] Component follows project naming conventions
- [ ] For screens: Subcomponents are properly decomposed
- [ ] For screens: Data interfaces are well-defined
- [ ] Import paths fixed (`@/utils/cn` not `@/utils/utils`)
